# --- Backend Makefile ---

# Define colors and icons for better readability
ESC := $(shell printf '\033')
BLUE := $(ESC)[38;2;30;144;255m
GREEN := $(ESC)[0;32m
YELLOW := $(ESC)[1;33m
RED := $(ESC)[0;31m
NC := $(ESC)[0m
TICK := $(GREEN)✔$(NC)
CROSS := $(RED)✖$(NC)
INFO := $(BLUE)ℹ$(NC)
WARN := $(YELLOW)⚠$(NC)
ARROW := $(BLUE)➜$(NC)

# Initialization method: set USE_DOCKER=1 for Docker, default is wget
USE_DOCKER ?= 0

# Cross-compiler configuration
CROSS_COMPILER_DIR := ./arm-linux-musleabi-cross
CROSS_COMPILER_URL := https://musl.cc/arm-linux-musleabi-cross.tgz
DOCKER := $(shell command -v docker 2>/dev/null || command -v podman 2>/dev/null)
DOCKER_IMAGE := localhost/arm-cross-cc
DOCKER_PLATFORM := linux/arm/v7

# Compiler flags (same for both methods)
CFLAGS := -DMIMEFILE=\""/etc/mime.types"\" \
	-DWEBFS_VERSION=\"1.22\" \
	-D_GNU_SOURCE \
	-D_LARGEFILE_SOURCE \
	-D_LARGEFILE64_SOURCE \
	-D_FILE_OFFSET_BITS=64
LDFLAGS := -static

# Set compiler based on initialization method
ifeq ($(USE_DOCKER),1)
	# Docker method: wrap compiler in container
	DOCKER_RUN = $(DOCKER) run --rm \
		--platform $(DOCKER_PLATFORM) \
		-v "$(CURDIR):/src:Z" \
		-w /src \
		$(DOCKER_IMAGE)
	CC = $(DOCKER_RUN) gcc
	STRIP = $(DOCKER_RUN) strip
else
	# Wget method: use downloaded cross-compiler (default)
	CC = $(CROSS_COMPILER_DIR)/bin/arm-linux-musleabi-gcc
	STRIP = $(CROSS_COMPILER_DIR)/bin/arm-linux-musleabi-strip
endif

SOURCE_FILES := $(wildcard *.c *.h)
OBJ := $(patsubst %.c,%.o,$(wildcard *.c))
TARGET := webfsd
STRIPPED_TARGET := $(TARGET).stripped
TARGET_DIR := ../webserver/opt/bin
TARGET_PATH := $(TARGET_DIR)/$(TARGET)
STAMP_DIR := .stamps
LINT_STAMP := $(STAMP_DIR)/.lint.stamp

.PHONY: all init build lint compile test clean help \
	build-only lint-only compile-only test-only \
	strip export-bin cross-cc clean-cc clean-docker

all: build ## Default target (same as build)

# init switches based on USE_DOCKER environment variable
ifeq ($(USE_DOCKER),1)
init: docker-image docker-warn ## Initialize with Docker (EXPERIMENTAL)
docker-warn:
	@echo ""
	@echo "$(WARN) WARNING: Docker build method is EXPERIMENTAL"
	@echo "$(WARN) Binary built with Alpine ARM gcc (not musl.cc)"
	@echo "$(WARN) Has NOT been tested on actual printer hardware"
	@echo "$(WARN) Use wget method for production builds"
	@echo ""
else
init: cross-cc ## Initialize backend with wget (default)
endif

cross-cc: $(CROSS_COMPILER_DIR) ## Download cross-compiler (wget method)

$(CROSS_COMPILER_DIR):
	@echo "$(BLUE)➜ Setting up backend environment...$(NC)"
ifeq ($(shell uname -s),Linux)
	@echo "$(INFO) Linux OS detected. Proceeding with cross-compiler download."
	mkdir -p $(CROSS_COMPILER_DIR)
	wget -qO- $(CROSS_COMPILER_URL) | tar -xz -C $(CROSS_COMPILER_DIR) --strip-components=1
	@echo "$(TICK) Cross-compiler downloaded and extracted."
else
	@echo "$(CROSS) Error: This build process requires a Linux environment for the cross-compiler."
	@exit 1
endif

docker-image: ## Build container image for cross-compilation
	@echo "$(BLUE)➜ Building container image...$(NC)"
	@if [ -z "$(DOCKER)" ]; then \
		echo "$(CROSS) Error: Neither docker nor podman found in PATH"; \
		exit 1; \
	fi
	@$(DOCKER) build \
		--platform $(DOCKER_PLATFORM) \
		-t $(DOCKER_IMAGE) \
		-f build.Dockerfile .
	@echo "$(TICK) Container image built"

docker-build: docker-image ## Build using container (cross-compile for ARM)
	@echo "$(BLUE)➜ Building in container...$(NC)"
	@$(DOCKER) run --rm --platform $(DOCKER_PLATFORM) \
		-v "$(CURDIR)/..:/workspace:Z" \
		-w /workspace/src \
		$(DOCKER_IMAGE)
	@echo "$(TICK) Container build complete"

$(TARGET): $(OBJ)
	@echo "$(BLUE)➜ Linking $@...$(NC)"
	@$(CC) $(LDFLAGS) -o $@ $^
	@echo "$(TICK) $@ linked."

$(STRIPPED_TARGET): $(TARGET)
	@echo "$(BLUE)➜ Stripping $(TARGET)...$(NC)"
	@$(STRIP) $(TARGET) -o $@
	@echo "$(TICK) $(TARGET) stripped."

test: compile ## Test the code (runs also: compile, init)

lint: init lint-only ## Lint the sources (runs also: init)

lint-only: $(LINT_STAMP) ## Lint the sources

$(LINT_STAMP): $(SOURCE_FILES)
	@echo "$(BLUE)➜ Checking sources with editorconfig-checker...$(NC)"
	@npx --yes editorconfig-checker || (echo "$(WARN) Some files don't match EditorConfig. Run 'make lint-fix' to see details." && exit 1)
	@echo "$(TICK) Sources match EditorConfig."
	@mkdir -p $(STAMP_DIR)
	@touch $(LINT_STAMP)

compile-only: $(TARGET) ## Compile the sources
compile: lint compile-only ## Compile the sources (runs also: init)

strip: $(STRIPPED_TARGET) ## Strip the binary

%.o: %.c
	@echo "$(BLUE)➜ Compiling $@...$(NC)"
	@$(CC) $(CFLAGS) -c $< -o $@


export-bin: $(STRIPPED_TARGET) $(TARGET_PATH) ## Export the binary

$(TARGET_PATH): strip
	@echo "$(BLUE)➜ Exporting binary to $(TARGET_DIR)...$(NC)"
	@mkdir -p $(TARGET_DIR)
	cp -f $(STRIPPED_TARGET) $@
	@echo "$(TICK) $(TARGET) exported."

build-only: strip export-bin ## Build the backend (runs: strip, export-bin)
build: compile build-only ## Build the backend (runs also: init, compile)

clean: ## Clean the backend
	@echo "$(BLUE)➜ Cleaning backend...$(NC)"
	rm -f $(OBJ) \
		$(TARGET) \
		$(STRIPPED_TARGET) \
		$(TARGET_PATH) \
		$(LINT_STAMP)
	rm -rf $(STAMP_DIR)

clean-cc: ## Delete the cross compiler
	@echo "$(BLUE)➜ Cleaning cross compiler...$(NC)"
	rm -rf $(CROSS_COMPILER_DIR)

clean-docker: ## Remove container image
	@echo "$(BLUE)➜ Removing container image...$(NC)"
	@$(DOCKER) rmi $(DOCKER_IMAGE) 2>/dev/null || true

help: ## Display this help message
	@echo "Usage: make [target]"
	@echo ""
	@echo "Targets:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  %-20s %s\n", $$1, $$2}'

.DEFAULT_GOAL := all
